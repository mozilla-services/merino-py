"""Curated Recommendations provider top-level request and response models"""

import hashlib
from enum import unique, Enum
from typing import Annotated
import logging
from datetime import datetime

import numpy as np
from pydantic import (
    Field,
    field_validator,
    model_validator,
    BaseModel,
    ValidationInfo,
    RootModel,
)

from merino.curated_recommendations.corpus_backends.protocol import (
    CorpusItem,
    Topic,
    SurfaceId,
    IABMetadata,
)
from merino.curated_recommendations.ml_backends.protocol import InferredLocalModel

logger = logging.getLogger(__name__)


@unique
class TypeName(str, Enum):
    """This value could be used in the future to distinguish between different types of content.

    Currently, the only value is recommendation.
    """

    RECOMMENDATION = "recommendation"


@unique
class Locale(str, Enum):
    """Supported locales for curated recommendations on New Tab"""

    FR = ("fr",)
    FR_FR = ("fr-FR",)
    ES = ("es",)
    ES_ES = ("es-ES",)
    IT = ("it",)
    IT_IT = ("it-IT",)
    EN = ("en",)
    EN_CA = ("en-CA",)
    EN_GB = ("en-GB",)
    EN_US = ("en-US",)
    DE = ("de",)
    DE_DE = ("de-DE",)
    DE_AT = ("de-AT",)
    DE_CH = ("de-CH",)

    @staticmethod
    def values():
        """Map enum values & returns"""
        return Locale._value2member_map_


@unique
class CoarseOS(str, Enum):
    """Supported operating systems at a coarse granularity."""

    MAC = "mac"
    WIN = "win"
    LINUX = "linux"
    ANDROID = "android"
    IOS = "ios"
    OTHER = "other"


@unique
class ExperimentName(str, Enum):
    """List of Nimbus experiment names on New Tab. This list is NOT meant to be exhaustive.
    This is simply intended to make it easier to reference experiment names in this codebase,
    when Merino needs to change behavior depending on the experimentName request parameter.
    """

    # Experiment where we apply a modified prior to reduce exploration
    MODIFIED_PRIOR_EXPERIMENT = "new-tab-feed-reduce-exploration"
    # Experiment to add sections generated by ML with editorial oversight
    ML_SECTIONS_EXPERIMENT = "new-tab-ml-sections"
    # Experiment to compare RSS vs. Zyte content sources for legacy topic sections
    RSS_VS_ZYTE_EXPERIMENT = "new-ranking-for-legacy-topics-in-new-tab-v1"


@unique
class CrawlExperimentBranchName(str, Enum):
    """Branch names for the RSS vs. Zyte (crawl) experiment."""

    CONTROL = "control"
    TREATMENT_CRAWL = "treatment-crawl"
    TREATMENT_CRAWL_PLUS_SUBTOPICS = "treatment-crawl-subtopics"


# Maximum tileId that Firefox can support. Firefox uses Javascript to store this value. The max
# value of a Javascript number can be found using `Number.MAX_SAFE_INTEGER`. which is 2^53 - 1
# because it uses a 64-bit IEEE 754 float.
# Generate tile_ids well out of the range of the old MySQL-based system, which has a max tile_id of
# 99,999 as of 2023-03-13. This is done to make it easy for engineers/analysts to see which system
# generated the identifier.
MAX_TILE_ID = (1 << 53) - 1
MIN_TILE_ID = 10000000


class InferredInterests(RootModel[dict[str, float | str | list[str]]]):
    """Raw inferred interests from client request - may contain encoded or decoded values"""

    @staticmethod
    def empty() -> "InferredInterests":
        """Return empty inferred interests"""
        return InferredInterests(root={})


class ProcessedInterests(BaseModel):
    """Internal representation of interests after processing/decoding"""

    minimum_value_count_for_normalization: int = 3
    model_id: str | None = None
    scores: dict[str, float] = Field(default_factory=dict)
    normalized_scores: dict[str, float] = Field(default_factory=dict)
    expected_keys: set[str] = Field(default_factory=set)

    @model_validator(mode="after")
    def compute_norm(self):
        """Set the normalized_scores dictionary with a normalized (1 max based) set
        of interests if the number of interests we have meet a minimum threshold, otherwise
        leave empty.

        If any key missing from the expected_keys, we set value to an average of the
        other values.
        """
        if len(self.scores) >= self.minimum_value_count_for_normalization:
            keys = list(self.scores.keys())
            values = np.array(list(self.scores.values()), dtype=float)
            normalized = values / (values.max() + 1e-6)
            normalized_dict: dict[str, float] = dict(zip(keys, normalized))
            for missing_key in self.expected_keys - normalized_dict.keys():  # Set intersection
                normalized_dict[missing_key] = normalized.mean()
            object.__setattr__(self, "normalized_scores", normalized_dict)
        return self

    @staticmethod
    def empty() -> "ProcessedInterests":
        """Return empty processed interests"""
        return ProcessedInterests()


class SectionConfiguration(BaseModel):
    """Configuration settings for a Section"""

    sectionId: str
    isFollowed: bool
    isBlocked: bool
    followedAt: datetime | None = Field(
        default=None,
        description="Timestamp when the section was followed. Must be in ISO 8601 format with timezone, "
        "e.g. '2024-03-24T12:34:56Z' or '2024-03-24T14:34:56+02:00'.",
    )

    @field_validator("followedAt", mode="before")
    def validate_followed_at(cls, followedAt):
        """Validate the followedAt param & ensures the timestamp is in the correct format."""
        if followedAt is None:
            return followedAt
        if isinstance(followedAt, datetime):
            if followedAt.tzinfo is None:
                raise ValueError("followedAt must have a timezone (e.g. 'Z' or '+02:00')")
            return followedAt
        if isinstance(followedAt, str):
            try:
                followed_at_iso = datetime.fromisoformat(followedAt)
            except ValueError:
                raise ValueError("followedAt must be a valid ISO 8601 datetime with timezone")
            if followed_at_iso.tzinfo is None:
                raise ValueError("followedAt must have a timezone (e.g. 'Z' or '+02:00')")
            return followed_at_iso
        raise ValueError(
            "followedAt must be a datetime or string in ISO 8601 format with timezone"
        )


class CuratedRecommendation(CorpusItem):
    """Extends CorpusItem with additional fields for a curated recommendation"""

    __typename: TypeName = TypeName.RECOMMENDATION
    experiment_flags: Annotated[set[str] | None, Field(default_factory=set, exclude=True)] = None
    tileId: Annotated[int | None, Field(strict=True, ge=MIN_TILE_ID, le=MAX_TILE_ID)] = None
    receivedRank: int
    features: dict[str, float] = Field(
        default_factory=dict,
        description="Maps feature names to weights, which the client "
        "can use to create a coarse interest vector.",
    )

    def in_experiment(self, experiment_name) -> bool:
        """Return if particular experiment name is associated with this experiment
        rescaler
        """
        return self.experiment_flags is not None and experiment_name in self.experiment_flags

    def update_scheduled_corpus_item_id(self, sid: str | None):
        """Scheduled corpus id and tile id are updated"""
        if sid is not None and self.tileId is None:
            self.tileId = self._integer_hash(sid, MIN_TILE_ID, MAX_TILE_ID)
        self.scheduledCorpusItemId = sid

    @model_validator(mode="before")
    def set_tileId(cls, values):
        """Set the tileId field automatically."""
        scheduled_corpus_item_id = values.get("scheduledCorpusItemId")

        if scheduled_corpus_item_id and "tileId" not in values:
            values["tileId"] = cls._integer_hash(
                scheduled_corpus_item_id, MIN_TILE_ID, MAX_TILE_ID
            )

        return values

    @staticmethod
    def _integer_hash(s: str, start: int, stop: int) -> int:
        """:param s: String to be hashed.
        :param start: Minimum integer to be returned.
        :param stop: Integer that is greater than start. Maximum return value is stop - 1.
        :return: Integer hash of s in the range [start, stop)
        """
        return start + (int(hashlib.sha256(s.encode("utf-8")).hexdigest(), 16) % (stop - start))


class CuratedRecommendationsRequest(BaseModel):
    """Body schema for requesting a list of curated recommendations"""

    locale: Locale
    region: str | None = None
    coarseOs: CoarseOS | None = None
    utcOffset: Annotated[int, Field(ge=0, le=24)] | None = None
    count: int = 100
    topics: list[Topic | str] | None = None
    feeds: list[str] | None = None
    sections: list[SectionConfiguration] | None = None
    # Firefox sends the name and branch for Nimbus experiments on the "pocketNewtab" feature:
    # https://searchfox.org/mozilla-central/source/browser/components/newtab/lib/DiscoveryStreamFeed.sys.mjs
    # Allow any string value or null, because ExperimentName is not meant to be an exhaustive list.
    experimentName: ExperimentName | str | None = None
    experimentBranch: str | None = None
    enableInterestPicker: bool = False
    inferredInterests: InferredInterests | None = None

    @field_validator("topics", mode="before")
    def validate_topics(cls, values):
        """Validate the topics param."""
        if values:
            if isinstance(values, list):
                valid_topics = []
                for value in values:
                    # if value is a valid Topic, add it to valid_topics
                    if isinstance(value, Topic):
                        valid_topics.append(value)
                    # if value is a string, check if its in enum Topic
                    # skip if invalid topic
                    elif isinstance(value, str):
                        try:
                            valid_topics.append(Topic(value))
                        except ValueError:
                            # Skip invalid topics
                            logger.warning(f"Invalid topic: {value}")
                            continue
                return valid_topics
            else:
                # Not wrapped in a list
                logger.warning(f"Topics not wrapped in a list: {values}")
        return []


@unique
class TileSize(str, Enum):
    """Defines possible sizes for a tile in the layout."""

    SMALL = "small"
    MEDIUM = "medium"
    LARGE = "large"


class Tile(BaseModel):
    """Defines properties for a single tile in a responsive layout."""

    size: TileSize
    position: int
    hasAd: bool
    hasExcerpt: bool

    @field_validator("hasExcerpt")
    def no_excerpt_on_small_tiles(cls, hasExcerpt, info: ValidationInfo):
        """Ensure small tiles do not have excerpts."""
        if info.data.get("size") == TileSize.SMALL and hasExcerpt:
            raise ValueError("Small tiles cannot have excerpts.")
        return hasExcerpt

    @field_validator("hasAd")
    def no_ad_on_small_or_large_tiles(cls, hasAd, info: ValidationInfo):
        """Ensure small and large tiles do not have ads."""
        if info.data.get("size") in {TileSize.SMALL, TileSize.LARGE} and hasAd:
            raise ValueError("Small or large tiles cannot have ads.")
        return hasAd


class ResponsiveLayout(BaseModel):
    """Defines layout properties for a specific column count."""

    columnCount: Annotated[int, Field(ge=1, le=4)]  # Restricts columnCount to integers from 1 to 4
    tiles: list[Tile]

    @field_validator("tiles")
    def validate_tile_positions(cls, tiles):
        """Ensure tile positions form a contiguous range from 0 to len(tiles) - 1, in any order."""
        if sorted(tile.position for tile in tiles) != list(range(len(tiles))):
            raise ValueError("ResponsiveLayout should not have a duplicate or missing position")
        return tiles


class Layout(BaseModel):
    """Defines a responsive layout configuration with multiple column layouts."""

    name: str
    responsiveLayouts: list[ResponsiveLayout]

    @field_validator("responsiveLayouts")
    def must_include_all_column_counts(cls, responsiveLayouts):
        """Ensure layouts include exactly one configuration for column counts 1 through 4."""
        if sorted(layout.columnCount for layout in responsiveLayouts) != [1, 2, 3, 4]:
            raise ValueError("Layout must have responsive layouts for 1, 2, 3, and 4 columns.")
        return responsiveLayouts

    @property
    def max_tile_count(self) -> int:
        """Get the maximum number of tiles in any responsive layout in this layout."""
        return max(len(rl.tiles) for rl in self.responsiveLayouts)


class Section(BaseModel):
    """A ranked list of curated recommendations with responsive layout configurations."""

    receivedFeedRank: int
    recommendations: list[CuratedRecommendation]
    title: str
    iab: IABMetadata | None = None
    subtitle: str | None = None
    layout: Layout
    isFollowed: bool = False
    isBlocked: bool = False
    followedAt: datetime | None = Field(
        default=None,
        description="Timestamp when the section was followed. Must be in ISO 8601 format with timezone, "
        "e.g. '2024-03-24T12:34:56Z' or '2024-03-24T14:34:56+02:00'.",
    )
    isInitiallyVisible: bool = True


class InterestPickerSection(BaseModel):
    """Model representing a single section entry in the interest picker."""

    sectionId: str


class InterestPicker(BaseModel):
    """Model representing the interest picker component for following sections."""

    receivedFeedRank: int
    title: str
    subtitle: str | None = None
    sections: list[InterestPickerSection]


class CuratedRecommendationsResponse(BaseModel):
    """Response schema for a list of curated recommendations"""

    recommendedAt: int
    surfaceId: SurfaceId
    data: list[CuratedRecommendation]
    feeds: dict[str, Section] | None = None
    interestPicker: InterestPicker | None = None
    inferredLocalModel: InferredLocalModel | None = None
