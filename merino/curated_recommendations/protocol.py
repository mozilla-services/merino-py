"""Curated Recommendations provider top-level request and response models"""

import hashlib
from enum import unique, Enum
from typing import Annotated
import logging
from datetime import datetime

from pydantic import Field, field_validator, model_validator, BaseModel, ValidationInfo

from merino.curated_recommendations.corpus_backends.protocol import (
    CorpusItem,
    Topic,
    SurfaceId,
)

logger = logging.getLogger(__name__)


@unique
class TypeName(str, Enum):
    """This value could be used in the future to distinguish between different types of content.

    Currently, the only value is recommendation.
    """

    RECOMMENDATION = "recommendation"


@unique
class Locale(str, Enum):
    """Supported locales for curated recommendations on New Tab"""

    FR = ("fr",)
    FR_FR = ("fr-FR",)
    ES = ("es",)
    ES_ES = ("es-ES",)
    IT = ("it",)
    IT_IT = ("it-IT",)
    EN = ("en",)
    EN_CA = ("en-CA",)
    EN_GB = ("en-GB",)
    EN_US = ("en-US",)
    DE = ("de",)
    DE_DE = ("de-DE",)
    DE_AT = ("de-AT",)
    DE_CH = ("de-CH",)

    @staticmethod
    def values():
        """Map enum values & returns"""
        return Locale._value2member_map_


# New Enum for coarse_os
@unique
class CoarseOS(str, Enum):
    """Supported operating systems at a coarse granularity."""

    MAC = "mac"
    WIN = "win"
    LINUX = "linux"
    ANDROID = "android"
    IOS = "ios"
    OTHER = "other"


@unique
class ExperimentName(str, Enum):
    """List of Nimbus experiment names on New Tab. This list is NOT meant to be exhaustive.
    This is simply intended to make it easier to reference experiment names in this codebase,
    when Merino needs to change behavior depending on the experimentName request parameter.
    """

    # Experiment where we apply a modified prior to reduce exploration
    MODIFIED_PRIOR_EXPERIMENT = "new-tab-feed-reduce-exploration"
    # Experiment to add sections generated by ML with editorial oversight
    ML_SECTIONS_EXPERIMENT = "new-tab-ml-sections"


# Maximum tileId that Firefox can support. Firefox uses Javascript to store this value. The max
# value of a Javascript number can be found using `Number.MAX_SAFE_INTEGER`. which is 2^53 - 1
# because it uses a 64-bit IEEE 754 float.
# Generate tile_ids well out of the range of the old MySQL-based system, which has a max tile_id of
# 99,999 as of 2023-03-13. This is done to make it easy for engineers/analysts to see which system
# generated the identifier.
MAX_TILE_ID = (1 << 53) - 1
MIN_TILE_ID = 10000000


class SectionConfiguration(BaseModel):
    """Configuration settings for a Section"""

    sectionId: str
    isFollowed: bool
    isBlocked: bool
    followedAt: datetime | None = Field(
        default=None,
        description="Timestamp when the section was followed. Must be in ISO 8601 format with timezone, "
        "e.g. '2024-03-24T12:34:56Z' or '2024-03-24T14:34:56+02:00'.",
    )

    @field_validator("followedAt", mode="before")
    def validate_followed_at(cls, followedAt):
        """Validate the followedAt param & ensures the timestamp is in the correct format."""
        if followedAt is None:
            return followedAt
        if isinstance(followedAt, datetime):
            if followedAt.tzinfo is None:
                raise ValueError("followedAt must have a timezone (e.g. 'Z' or '+02:00')")
            return followedAt
        if isinstance(followedAt, str):
            try:
                followed_at_iso = datetime.fromisoformat(followedAt)
            except ValueError:
                raise ValueError("followedAt must be a valid ISO 8601 datetime with timezone")
            if followed_at_iso.tzinfo is None:
                raise ValueError("followedAt must have a timezone (e.g. 'Z' or '+02:00')")
            return followed_at_iso
        raise ValueError(
            "followedAt must be a datetime or string in ISO 8601 format with timezone"
        )


class CuratedRecommendation(CorpusItem):
    """Extends CorpusItem with additional fields for a curated recommendation"""

    __typename: TypeName = TypeName.RECOMMENDATION
    tileId: Annotated[int | None, Field(strict=True, ge=MIN_TILE_ID, le=MAX_TILE_ID)] = None
    receivedRank: int

    @model_validator(mode="before")
    def set_tileId(cls, values):
        """Set the tileId field automatically."""
        scheduled_corpus_item_id = values.get("scheduledCorpusItemId")

        if scheduled_corpus_item_id and "tileId" not in values:
            values["tileId"] = cls._integer_hash(
                scheduled_corpus_item_id, MIN_TILE_ID, MAX_TILE_ID
            )

        return values

    @staticmethod
    def _integer_hash(s: str, start: int, stop: int) -> int:
        """:param s: String to be hashed.
        :param start: Minimum integer to be returned.
        :param stop: Integer that is greater than start. Maximum return value is stop - 1.
        :return: Integer hash of s in the range [start, stop)
        """
        return start + (int(hashlib.sha256(s.encode("utf-8")).hexdigest(), 16) % (stop - start))


class CuratedRecommendationsRequest(BaseModel):
    """Body schema for requesting a list of curated recommendations"""

    locale: Locale
    region: str | None = None
    coarseOs: CoarseOS | None = None
    utcOffset: Annotated[int, Field(ge=0, le=24)] | None = None
    count: int = 100
    topics: list[Topic | str] | None = None
    feeds: list[str] | None = None
    sections: list[SectionConfiguration] | None = None
    # Firefox sends the name and branch for Nimbus experiments on the "pocketNewtab" feature:
    # https://searchfox.org/mozilla-central/source/browser/components/newtab/lib/DiscoveryStreamFeed.sys.mjs
    # Allow any string value or null, because ExperimentName is not meant to be an exhaustive list.
    experimentName: ExperimentName | str | None = None
    experimentBranch: str | None = None
    enableInterestPicker: bool = False

    @field_validator("topics", mode="before")
    def validate_topics(cls, values):
        """Validate the topics param."""
        if values:
            if isinstance(values, list):
                valid_topics = []
                for value in values:
                    # if value is a valid Topic, add it to valid_topics
                    if isinstance(value, Topic):
                        valid_topics.append(value)
                    # if value is a string, check if its in enum Topic
                    # skip if invalid topic
                    elif isinstance(value, str):
                        try:
                            valid_topics.append(Topic(value))
                        except ValueError:
                            # Skip invalid topics
                            logger.warning(f"Invalid topic: {value}")
                            continue
                return valid_topics
            else:
                # Not wrapped in a list
                logger.warning(f"Topics not wrapped in a list: {values}")
        return []


@unique
class TileSize(str, Enum):
    """Defines possible sizes for a tile in the layout."""

    SMALL = "small"
    MEDIUM = "medium"
    LARGE = "large"


class Tile(BaseModel):
    """Defines properties for a single tile in a responsive layout."""

    size: TileSize
    position: int
    hasAd: bool
    hasExcerpt: bool

    @field_validator("hasExcerpt")
    def no_excerpt_on_small_tiles(cls, hasExcerpt, info: ValidationInfo):
        """Ensure small tiles do not have excerpts."""
        if info.data.get("size") == TileSize.SMALL and hasExcerpt:
            raise ValueError("Small tiles cannot have excerpts.")
        return hasExcerpt

    @field_validator("hasAd")
    def no_ad_on_small_or_large_tiles(cls, hasAd, info: ValidationInfo):
        """Ensure small and large tiles do not have ads."""
        if info.data.get("size") in {TileSize.SMALL, TileSize.LARGE} and hasAd:
            raise ValueError("Small or large tiles cannot have ads.")
        return hasAd


class ResponsiveLayout(BaseModel):
    """Defines layout properties for a specific column count."""

    columnCount: Annotated[int, Field(ge=1, le=4)]  # Restricts columnCount to integers from 1 to 4
    tiles: list[Tile]

    @field_validator("tiles")
    def validate_tile_positions(cls, tiles):
        """Ensure tile positions form a contiguous range from 0 to len(tiles) - 1, in any order."""
        if sorted(tile.position for tile in tiles) != list(range(len(tiles))):
            raise ValueError("ResponsiveLayout should not have a duplicate or missing position")
        return tiles


class Layout(BaseModel):
    """Defines a responsive layout configuration with multiple column layouts."""

    name: str
    responsiveLayouts: list[ResponsiveLayout]

    @field_validator("responsiveLayouts")
    def must_include_all_column_counts(cls, responsiveLayouts):
        """Ensure layouts include exactly one configuration for column counts 1 through 4."""
        if sorted(layout.columnCount for layout in responsiveLayouts) != [1, 2, 3, 4]:
            raise ValueError("Layout must have responsive layouts for 1, 2, 3, and 4 columns.")
        return responsiveLayouts

    @property
    def max_tile_count(self) -> int:
        """Get the maximum number of tiles in any responsive layout in this layout."""
        return max(len(rl.tiles) for rl in self.responsiveLayouts)


class Section(BaseModel):
    """A ranked list of curated recommendations with responsive layout configurations."""

    receivedFeedRank: int
    recommendations: list[CuratedRecommendation]
    title: str
    subtitle: str | None = None
    layout: Layout
    isFollowed: bool = False
    isBlocked: bool = False
    followedAt: datetime | None = Field(
        default=None,
        description="Timestamp when the section was followed. Must be in ISO 8601 format with timezone, "
        "e.g. '2024-03-24T12:34:56Z' or '2024-03-24T14:34:56+02:00'.",
    )

    isInitiallyVisible: bool = True


class InterestPickerSection(BaseModel):
    """Model representing a single section entry in the interest picker."""

    sectionId: str


class InterestPicker(BaseModel):
    """Model representing the interest picker component for following sections."""

    receivedFeedRank: int
    title: str
    subtitle: str | None = None
    sections: list[InterestPickerSection]


class CuratedRecommendationsResponse(BaseModel):
    """Response schema for a list of curated recommendations"""

    recommendedAt: int
    surfaceId: SurfaceId
    data: list[CuratedRecommendation]
    feeds: dict[str, Section] | None = None
    interestPicker: InterestPicker | None = None
