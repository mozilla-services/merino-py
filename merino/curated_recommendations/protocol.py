"""Curated Recommendations provider top-level request and response models"""

import hashlib
from enum import unique, Enum
import math
from typing import Annotated
import logging
from datetime import datetime
import numbers

import numpy as np
from pydantic import (
    Field,
    field_validator,
    model_validator,
    BaseModel,
    ValidationInfo,
    RootModel,
    ConfigDict,
)

from merino.curated_recommendations.corpus_backends.protocol import (
    CorpusItem,
    Topic,
    SurfaceId,
    IABMetadata,
)
from merino.curated_recommendations.ml_backends.protocol import InferredLocalModel

logger = logging.getLogger(__name__)


@unique
class TypeName(str, Enum):
    """This value could be used in the future to distinguish between different types of content.

    Currently, the only value is recommendation.
    """

    RECOMMENDATION = "recommendation"


@unique
class Locale(str, Enum):
    """Supported locales for curated recommendations on New Tab"""

    FR = ("fr",)
    FR_FR = ("fr-FR",)
    ES = ("es",)
    ES_ES = ("es-ES",)
    IT = ("it",)
    IT_IT = ("it-IT",)
    EN = ("en",)
    EN_CA = ("en-CA",)
    EN_GB = ("en-GB",)
    EN_US = ("en-US",)
    DE = ("de",)
    DE_DE = ("de-DE",)
    DE_AT = ("de-AT",)
    DE_CH = ("de-CH",)

    @staticmethod
    def values():
        """Map enum values & returns"""
        return Locale._value2member_map_


@unique
class CoarseOS(str, Enum):
    """Supported operating systems at a coarse granularity."""

    MAC = "mac"
    WIN = "win"
    LINUX = "linux"
    ANDROID = "android"
    IOS = "ios"
    OTHER = "other"


@unique
class ExperimentName(str, Enum):
    """List of Nimbus experiment names on New Tab. This list is NOT meant to be exhaustive.
    This is simply intended to make it easier to reference experiment names in this codebase,
    when Merino needs to change behavior depending on the experimentName request parameter.
    """

    # Experiment where we apply a modified prior to reduce exploration
    MODIFIED_PRIOR_EXPERIMENT = "new-tab-feed-reduce-exploration"
    # Experiment to add sections generated by ML with editorial oversight
    ML_SECTIONS_EXPERIMENT = "new-tab-ml-sections"
    # Experiment to compare RSS vs. Zyte content sources for legacy topic sections
    SCHEDULER_HOLDBACK_EXPERIMENT = "new-tab-topic-feeds-rollout-holdback"

    RSS_VS_ZYTE_EXPERIMENT = "new-ranking-for-legacy-topics-in-new-tab-v1"
    # Experiment to display Daily Briefing section as the first section on New Tab
    DAILY_BRIEFING_EXPERIMENT = "daily-briefing-v1"
    # The following are 6 experiments to apply 1 row layout for Popular Today for contextual ads
    CONTEXTUAL_AD_NIGHTLY_EXPERIMENT = "new-tab-ad-updates-nightly"
    CONTEXTUAL_AD_V2_NIGHTLY_EXPERIMENT = "new-tab-contextual-ad-updates-v2-nightly"
    CONTEXTUAL_AD_BETA_EXPERIMENT = "new-tab-contextual-ad-updates-beta"
    CONTEXTUAL_AD_V2_BETA_EXPERIMENT = "new-tab-contextual-ad-updates-v2-beta"
    CONTEXTUAL_AD_RELEASE_EXPERIMENT = "new-tab-contextual-ad-updates-release"
    CONTEXTUAL_AD_V2_RELEASE_EXPERIMENT = "new-tab-contextual-ad-updates-v2-release"
    NEW_TAB_CUSTOM_SECTIONS_EXPERIMENT = "new-tab-custom-sections"
    CONTEXTUAL_RANKING_CONTENT_EXPERIMENT = "content-contextual-ranking"

    # Experiment for doing local reranking of popular today via inferred interests
    INFERRED_LOCAL_EXPERIMENT = "new-tab-automated-personalization-local-ranking"
    INFERRED_LOCAL_EXPERIMENT_V2 = "new-tab-automated-personalization-local-ranking-2"
    INFERRED_LOCAL_EXPERIMENT_V3 = "new-tab-automated-personalization-v3"


class DailyBriefingBranch(str, Enum):
    """Treatment branches for the Daily Briefing experiment."""

    # Show Daily Briefing (headlines) section WITH Popular Today section
    BRIEFING_WITH_POPULAR = "briefing-with-popular"
    # Show Daily Briefing (headlines) section WITHOUT Popular Today section
    BRIEFING_WITHOUT_POPULAR = "briefing-without-popular"


# Maximum tileId that Firefox can support. Firefox uses Javascript to store this value. The max
# value of a Javascript number can be found using `Number.MAX_SAFE_INTEGER`. which is 2^53 - 1
# because it uses a 64-bit IEEE 754 float.
# Generate tile_ids well out of the range of the old MySQL-based system, which has a max tile_id of
# 99,999 as of 2023-03-13. This is done to make it easy for engineers/analysts to see which system
# generated the identifier.
MAX_TILE_ID = (1 << 53) - 1
MIN_TILE_ID = 10000000


class InferredInterests(RootModel[dict[str, float | str | list[str]]]):
    """Raw inferred interests from client request - may contain encoded or decoded values"""

    @staticmethod
    def empty() -> "InferredInterests":
        """Return empty inferred interests"""
        return InferredInterests(root={})

    def get_model_used(self) -> str | None:
        """Return the id of the model used to create this inferred interest, if valid"""
        return (
            self.root["model_id"]
            if ("model_id" in self.root and isinstance(self.root["model_id"], str))
            else None
        )


class ProcessedInterests(BaseModel):
    """Internal representation of interests after processing/decoding"""

    minimum_value_count_for_normalization: int = 3
    model_id: str | None = None
    scores: dict[str, float] = Field(default_factory=dict)
    normalized_scores: dict[str, float] = Field(default_factory=dict)
    expected_keys: set[str] = Field(default_factory=set)
    skip_normalization: bool = False

    @model_validator(mode="after")
    def compute_norm(self) -> "ProcessedInterests":
        """Set the normalized_scores dictionary with an L2-normalized (unit length) set
        of interests if the number of interests we have meets a minimum threshold,
        otherwise leave empty.

        If any key is missing from the expected_keys, we set its value to the mean
        of the normalized values.
        """
        if self.skip_normalization and len(self.scores) > 0:
            """ Note this scenarios is not being used but may be soon. If not used Jan 2026 it can be removed."""
            pre_normalized_dict = self.scores.copy()
            values = np.array(list(self.scores.values()), dtype=float)
            for missing_key in self.expected_keys - pre_normalized_dict.keys():
                pre_normalized_dict[missing_key] = values.mean()
            object.__setattr__(self, "normalized_scores", pre_normalized_dict)
        elif len(self.scores) >= self.minimum_value_count_for_normalization:
            keys = list(self.scores.keys())
            values = np.array(list(self.scores.values()), dtype=float)

            # Compute L2 norm (Euclidean length)
            norm = np.linalg.norm(values) + 1e-6
            normalized = values / norm

            normalized_dict: dict[str, float] = dict(zip(keys, normalized))

            # Fill in missing expected keys with mean
            mean_val = normalized.mean()
            for missing_key in self.expected_keys - normalized_dict.keys():
                normalized_dict[missing_key] = mean_val
            object.__setattr__(self, "normalized_scores", normalized_dict)
        return self

    @staticmethod
    def empty() -> "ProcessedInterests":
        """Return empty processed interests"""
        return ProcessedInterests()


class SectionConfiguration(BaseModel):
    """Configuration settings for a Section"""

    sectionId: str
    isFollowed: bool
    isBlocked: bool
    followedAt: datetime | None = Field(
        default=None,
        description="Timestamp when the section was followed. Must be in ISO 8601 format with timezone, "
        "e.g. '2024-03-24T12:34:56Z' or '2024-03-24T14:34:56+02:00'.",
    )

    @field_validator("followedAt", mode="before")
    def validate_followed_at(cls, followedAt):
        """Validate the followedAt param & ensures the timestamp is in the correct format."""
        if followedAt is None:
            return followedAt
        if isinstance(followedAt, datetime):
            if followedAt.tzinfo is None:
                raise ValueError("followedAt must have a timezone (e.g. 'Z' or '+02:00')")
            return followedAt
        if isinstance(followedAt, str):
            try:
                followed_at_iso = datetime.fromisoformat(followedAt)
            except ValueError:
                raise ValueError("followedAt must be a valid ISO 8601 datetime with timezone")
            if followed_at_iso.tzinfo is None:
                raise ValueError("followedAt must have a timezone (e.g. 'Z' or '+02:00')")
            return followed_at_iso
        raise ValueError(
            "followedAt must be a datetime or string in ISO 8601 format with timezone"
        )


class RankingData(BaseModel):
    """Data used to compute score, and current computed score"""

    alpha: float
    beta: float
    score: float
    is_fresh: bool = False  # Indicates it has relatively little impressions


# Flags for in_experiment flags. Note that the name in_experiment is historical and should be migrated to a new name
ITEM_SUBTOPIC_FLAG = "SUBTOPICS"


class CuratedRecommendation(CorpusItem):
    """Extends CorpusItem with additional fields for a curated recommendation"""

    __typename: TypeName = TypeName.RECOMMENDATION

    experiment_flags: Annotated[set[str] | None, Field(default_factory=set, exclude=True)] = None
    ranking_data: Annotated[RankingData | None, Field(exclude=True)] = None
    tileId: Annotated[int | None, Field(strict=True, ge=MIN_TILE_ID, le=MAX_TILE_ID)] = None
    receivedRank: int
    serverScore: float | None = None
    features: dict[str, float] = Field(
        default_factory=dict,
        description="Maps feature names to weights, which the client "
        "can use to create a coarse interest vector.",
    )

    def in_experiment(self, experiment_name) -> bool:
        """Return if particular experiment name is associated with this experiment
        rescaler
        """
        return self.experiment_flags is not None and experiment_name in self.experiment_flags

    def update_scheduled_corpus_item_id(self, sid: str | None):
        """Scheduled corpus id and tile id are updated"""
        if sid is not None and self.tileId is None:
            self.tileId = self._integer_hash(sid, MIN_TILE_ID, MAX_TILE_ID)
        self.scheduledCorpusItemId = sid

    def is_story_blocked_for_top_stories(self) -> bool:
        """Return true if the story should be blocked from most popular section."""
        return self.in_experiment(ITEM_SUBTOPIC_FLAG) or self.topic == Topic.GAMING

    @model_validator(mode="before")
    def set_tileId(cls, values):
        """Set the tileId field automatically."""
        scheduled_corpus_item_id = values.get("scheduledCorpusItemId")

        if scheduled_corpus_item_id and "tileId" not in values:
            values["tileId"] = cls._integer_hash(
                scheduled_corpus_item_id, MIN_TILE_ID, MAX_TILE_ID
            )

        return values

    @staticmethod
    def _integer_hash(s: str, start: int, stop: int) -> int:
        """:param s: String to be hashed.
        :param start: Minimum integer to be returned.
        :param stop: Integer that is greater than start. Maximum return value is stop - 1.
        :return: Integer hash of s in the range [start, stop)
        """
        return start + (int(hashlib.sha256(s.encode("utf-8")).hexdigest(), 16) % (stop - start))


class CuratedRecommendationsRequest(BaseModel):
    """Body schema for requesting a list of curated recommendations"""

    model_config = ConfigDict(populate_by_name=True)

    locale: Locale
    region: str | None = None
    coarseOs: CoarseOS | None = None
    utcOffset: Annotated[
        int | None,
        Field(
            alias="utc_offset",
            ge=0,
            le=23,
            description="UTC offset in hours. Must be between 0 and 23 inclusive.",
        ),
    ] = None
    count: int = 100
    topics: list[Topic | str] | None = None
    feeds: list[str] | None = None
    sections: list[SectionConfiguration] | None = None
    # Firefox sends the name and branch for Nimbus experiments on the "pocketNewtab" feature:
    # https://searchfox.org/mozilla-central/source/browser/components/newtab/lib/DiscoveryStreamFeed.sys.mjs
    # Allow any string value or null, because ExperimentName is not meant to be an exhaustive list.
    experimentName: ExperimentName | str | None = None
    experimentBranch: str | None = None
    enableInterestPicker: bool = False
    inferredInterests: InferredInterests | None = None

    @field_validator("utcOffset", mode="before")
    def validate_utc_offset(cls, value):
        """Validate the utcOffset param and coerce invalid values to None."""
        if value is None:
            return None
        if isinstance(value, numbers.Real):
            # reject NaN or infinities
            if math.isfinite(value):
                value_int = int(value)
                if 0 <= value_int <= 23:
                    return value_int
            return None
        # If string, consider invalid
        return None

    @field_validator("topics", mode="before")
    def validate_topics(cls, values):
        """Validate the topics param."""
        if values:
            if isinstance(values, list):
                valid_topics = []
                for value in values:
                    # if value is a valid Topic, add it to valid_topics
                    if isinstance(value, Topic):
                        valid_topics.append(value)
                    # if value is a string, check if its in enum Topic
                    # skip if invalid topic
                    elif isinstance(value, str):
                        try:
                            valid_topics.append(Topic(value))
                        except ValueError:
                            # Skip invalid topics
                            logger.warning(f"Invalid topic: {value}")
                            continue
                return valid_topics
            else:
                # Not wrapped in a list
                logger.warning(f"Topics not wrapped in a list: {values}")
        return []


@unique
class TileSize(str, Enum):
    """Defines possible sizes for a tile in the layout."""

    SMALL = "small"
    MEDIUM = "medium"
    LARGE = "large"


class Tile(BaseModel):
    """Defines properties for a single tile in a responsive layout."""

    size: TileSize
    position: int
    hasAd: bool
    hasExcerpt: bool

    @field_validator("hasExcerpt")
    def no_excerpt_on_small_tiles(cls, hasExcerpt, info: ValidationInfo):
        """Ensure small tiles do not have excerpts."""
        if info.data.get("size") == TileSize.SMALL and hasExcerpt:
            raise ValueError("Small tiles cannot have excerpts.")
        return hasExcerpt

    @field_validator("hasAd")
    def no_ad_on_small_or_large_tiles(cls, hasAd, info: ValidationInfo):
        """Ensure small and large tiles do not have ads."""
        if info.data.get("size") in {TileSize.SMALL, TileSize.LARGE} and hasAd:
            raise ValueError("Small or large tiles cannot have ads.")
        return hasAd


class ResponsiveLayout(BaseModel):
    """Defines layout properties for a specific column count."""

    columnCount: Annotated[int, Field(ge=1, le=4)]  # Restricts columnCount to integers from 1 to 4
    tiles: list[Tile]

    @field_validator("tiles")
    def validate_tile_positions(cls, tiles):
        """Ensure tile positions form a contiguous range from 0 to len(tiles) - 1, in any order."""
        if sorted(tile.position for tile in tiles) != list(range(len(tiles))):
            raise ValueError("ResponsiveLayout should not have a duplicate or missing position")
        return tiles


class Layout(BaseModel):
    """Defines a responsive layout configuration with multiple column layouts."""

    name: str
    responsiveLayouts: list[ResponsiveLayout]

    @field_validator("responsiveLayouts")
    def must_include_all_column_counts(cls, responsiveLayouts):
        """Ensure layouts include exactly one configuration for column counts 1 through 4."""
        if sorted(layout.columnCount for layout in responsiveLayouts) != [1, 2, 3, 4]:
            raise ValueError("Layout must have responsive layouts for 1, 2, 3, and 4 columns.")
        return responsiveLayouts

    @property
    def max_tile_count(self) -> int:
        """Get the maximum number of tiles in any responsive layout in this layout."""
        return max(len(rl.tiles) for rl in self.responsiveLayouts)


class Section(BaseModel):
    """A ranked list of curated recommendations with responsive layout configurations."""

    receivedFeedRank: int
    recommendations: list[CuratedRecommendation]
    title: str
    iab: IABMetadata | None = None
    subtitle: str | None = None
    heroTitle: str | None = None
    heroSubtitle: str | None = None
    layout: Layout
    isFollowed: bool = False
    isBlocked: bool = False
    followedAt: datetime | None = Field(
        default=None,
        description="Timestamp when the section was followed. Must be in ISO 8601 format with timezone, "
        "e.g. '2024-03-24T12:34:56Z' or '2024-03-24T14:34:56+02:00'.",
    )
    isInitiallyVisible: bool = True


class InterestPickerSection(BaseModel):
    """Model representing a single section entry in the interest picker."""

    sectionId: str


class InterestPicker(BaseModel):
    """Model representing the interest picker component for following sections."""

    receivedFeedRank: int
    title: str
    subtitle: str | None = None
    sections: list[InterestPickerSection]


class CuratedRecommendationsResponse(BaseModel):
    """Response schema for a list of curated recommendations"""

    recommendedAt: int
    surfaceId: SurfaceId
    data: list[CuratedRecommendation]
    feeds: dict[str, Section] | None = None
    interestPicker: InterestPicker | None = None
    inferredLocalModel: InferredLocalModel | None = None
